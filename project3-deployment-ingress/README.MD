He tenido problemas para conseguir esto con mi WSL  + Docker Desktop. 

Aqui los pasos y causas , hasta la solucion

A continuaciÃ³n tienes un paso a paso bastante detallado para diagnosticar y resolver por quÃ©, aÃºn ejecutando minikube tunnel, tu Ingress no responde en http://rollingdemo.local. El objetivo es que verifiques cada punto y veas exactamente dÃ³nde estÃ¡ la traba.

Resumen rÃ¡pido: Con WSL2 + Docker Desktop + Minikube, la IP 192.168.49.x normalmente no es alcanzable sin un tÃºnel. Usar minikube tunnel deberÃ­a exponer la misma IP que te da minikube ip, y asÃ­ (con un /etc/hosts que asocie rollingdemo.local a esa IP) poder hacer curl http://rollingdemo.local. Pero a veces entran en juego otros factores (sudo no concedido, conflicto en el puerto 80, firewall, etc.).

1. Confirmar que â€œrolllingdemo.localâ€ resuelve a 192.168.49.2 en WSL
En tu consola de WSL, haz:
bash
Copiar cÃ³digo
cat /etc/hosts | grep rollingdemo.local
Debe aparecer la lÃ­nea:
lua
Copiar cÃ³digo
192.168.49.2    rollingdemo.local
Verifica que efectivamente resuelva a esa IP:
bash
Copiar cÃ³digo
getent hosts rollingdemo.local
# o
ping -c 2 rollingdemo.local
Si no te da respuesta, algo estÃ¡ mal con /etc/hosts.
Si responde a 192.168.49.2, vamos bien al menos en DNS.
2. Revisar si el â€œtunnelâ€ estÃ¡ realmente activo y autorizado
Cuando corres:

bash
Copiar cÃ³digo
minikube tunnel
verÃ¡s algo como:

rust
Copiar cÃ³digo
â—  The service/ingress rolling-ing requires privileged ports to be exposed: [80 443]
ðŸ”‘  sudo permission will be asked for it.
ðŸƒ  Starting tunnel for service rolling-ing.
A veces WSL pedirÃ¡ la contraseÃ±a de sudo (o un sudo prompt) para poder bindear los puertos 80/443 en la interfaz â€œdel hostâ€. AsegÃºrate de escribir bien tu contraseÃ±a y no cerrar esa ventana.

2.1. Confirmar que realmente estÃ¡ escuchando
Abre otra terminal de WSL (deja la de minikube tunnel corriendo) y ejecuta:

bash
Copiar cÃ³digo
sudo lsof -i -P -n | grep LISTEN | grep -E '80|443'
Si no aparece nada escuchando en :80 o :443 en nombre de minikube o algo similar, entonces es que el tÃºnel no se pudo levantar.
Si sÃ­ aparece un proceso de vpnkit / minikube / â€œsomethingâ€ en *:80, significa que estÃ¡ escuchando.
A veces, si Docker Desktop tambiÃ©n ocupa el puerto 80, puede haber conflicto. Revisa que ningÃºn otro servicio (Apache, NGINX local, etc.) estÃ© ya en el puerto 80.

3. Verificar la conexiÃ³n al Ingress dentro de WSL
Sigue con la consola donde ya tienes minikube tunnel activo y haz:

bash
Copiar cÃ³digo
curl -v -H "Host: rollingdemo.local" http://127.0.0.1
Â¿Por quÃ© 127.0.0.1 en lugar de rollingdemo.local?

Porque con minikube tunnel, en muchos casos minikube expone el Ingress/LoadBalancer en localhost:80 (o en la IP que minikube crea internamente).
Importante: El Ingress hace host-based routing usando el encabezado Host: rollingdemo.local.
Si no incluyes -H "Host: rollingdemo.local", es probable que NGINX no encuentre la regla y te devuelva 404 Not Found (el â€œdefault backendâ€).
Si ese comando (con -H) te devuelve 200 OK y muestra â€œVERSION 1â€, significa que el tÃºnel sÃ­ estÃ¡ funcionando y que la peticiÃ³n estÃ¡ entrando al Ingress.

Si obtienes curl: (7) Connection refused o Timeout, tu tÃºnel no estÃ¡ realmente en marcha.
Si obtienes 404 Not Found, el Ingress estÃ¡ recibiendo el trÃ¡fico, pero no coincide con la regla de host. AsegÃºrate de poner -H "Host: rollingdemo.local".
3.1. Luego probar con curl -v http://rollingdemo.local
Si la lÃ­nea en /etc/hosts es 192.168.49.2 rollingdemo.local y el tÃºnel estÃ¡ redirigiendo 192.168.49.2:80 â†’ contenedor, teÃ³ricamente tambiÃ©n deberÃ­a funcionar. Pero a veces en WSL2 la ruta a 192.168.49.2 difiere de la que se configura en localhost.

Si te vuelve a dar â€œConnection timed outâ€, puede indicar que la red de WSL no estÃ¡ permitiendo llegar a 192.168.49.2 aunque el tÃºnel estÃ© abierto.
Una prueba rÃ¡pida:

bash
Copiar cÃ³digo
ping -c 2 192.168.49.2
Si ni siquiera ping contesta, es muy probable que no haya NAT hacia esa IP.
En algunos setups de WSL, localhost sÃ­ funciona, pero 192.168.49.2 no.
AsÃ­ que, en entornos WSL, es frecuente que â€œlocalhostâ€ sea la forma en que el tÃºnel funciona. Esto es lo que produce el famoso nginx 404 al no matchear el host, a menos que agregues la cabecera Host: rollingdemo.local.

4. â€œPero me abre el navegador en http://localhost/ y veo 404 Not Found, Â¿por quÃ©?â€
Porque tu Ingress tiene la siguiente regla en ingress.yaml:

yaml
Copiar cÃ³digo
spec:
  rules:
    - host: rollingdemo.local
      http:
        paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: rolling-svc
              port:
                number: 80
El NGINX Ingress sÃ³lo atiende la ruta / si el Host HTTP es rollingdemo.local.
Cuando abres http://localhost/ en el navegador, tu navegador manda Host: localhost. El Ingress no tiene ninguna regla para ese host â†’ responde con el backend default (404).

Soluciones para ver algo en http://localhost/ directamente:

OpciÃ³n rÃ¡pida: En lugar de usar host: rollingdemo.local en tu Ingress, omitir la secciÃ³n host: y poner:

yaml
Copiar cÃ³digo
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: rolling-svc
            port:
              number: 80
Entonces cualquier host (localhost, 127.0.0.1, etc.) matchea y te servirÃ¡ la app.
Pero pierdes la funcionalidad de host-based routing.

O bien: Mantener host: rollingdemo.local, y cuando quieras probar con http://localhost, aÃ±adir manualmente -H "Host: rollingdemo.local" en el curl, o en tu navegador hacer un override del Host. (En un navegador normal, eso es mÃ¡s complicado sin plugin, por eso preferimos /etc/hosts).

Seguir usando rollingdemo.local en la barra de direcciones del navegador, y en el /etc/hosts (o en Windows C:\Windows\System32\drivers\etc\hosts) poner 127.0.0.1 rollingdemo.local.

Entonces http://rollingdemo.local y Host: rollingdemo.local coinciden, y el Ingress harÃ¡ match.
Â¡Y ojo!, a veces es mejor apuntar a 127.0.0.1 (en vez de 192.168.49.2) si el tÃºnel estÃ¡ realmente escuchando en localhost.
5. Chequeos de firewall y puertos
Si todo lo anterior no funciona y sigues con â€œtimeoutâ€, revisa:

Â¿EstÃ¡ Docker Desktop u otro servicio usando ya el puerto 80 en WSL?
sudo netstat -tunlp | grep :80
Â¿Le diste efectivamente el sudo password al minikube tunnel?
Si el tÃºnel no logra binding a 80, no va a enrutarte nada.
Firewall en WSL: Normalmente, en Ubuntu dentro de WSL no hay ufw activo por defecto, pero revisa con:
sudo ufw status
Si estÃ¡ â€œactiveâ€, prueba sudo ufw allow 80 o desactÃ­valo para test.
VersiÃ³n de minikube y driver:
AsegÃºrate de tener algo relativamente actualizado: minikube version
Confirma que tu driver sea docker (que es lo usual con Docker Desktop).
El contenedor NGINX Ingress ya vimos que estÃ¡ Running y no hay errores en logs.
6. Resumen del plan de ataque
Ejecutar minikube tunnel en una consola. Concede permisos de sudo cuando lo pida.

Ver si tienes 2 opciones para â€œa dÃ³ndeâ€ conectar:

OpciÃ³n A:

/etc/hosts â†’ 127.0.0.1 rollingdemo.local
Abrir http://rollingdemo.local/ en WSL o en Windows.
Con host: rollingdemo.local, el Ingress harÃ¡ match.
Si ves â€œ404 Not Foundâ€, puede ser que tu navegador estÃ© usando Host: localhost, no â€œrollingdemo.localâ€. AsegÃºrate que la barra de direcciones ponga â€œrollingdemo.localâ€.
OpciÃ³n B:

/etc/hosts â†’ 192.168.49.2 rollingdemo.local
Pero en WSL2 a veces no hay ruta a 192.168.49.2 aunque el tÃºnel estÃ© activo.
Revisa con ping 192.168.49.2.
A menudo la forma mÃ¡s fiable es apuntar a localhost.
Test con curl -v -H "Host: rollingdemo.local" http://127.0.0.1 (o con la IP a la que tengas en hosts).

Si aquÃ­ obtienes 200 OK y â€œVERSION 1â€, el Ingress estÃ¡ funcionando.
Si a pesar de todo curl se cuelga (â€œConnection timed outâ€):

Comprueba que no tengas un firewall local.
Comprueba que tu minikube tunnel no se estÃ© cerrando por error.
Observa si minikube tunnel muestra algÃºn log adicional o error.
7. Â¿Por quÃ© me abriÃ³ un navegador en â€œhttp://localhost/â€ con 404?
Porque minikube tunnel a veces, al exponer un Service/Ingress en puerto 80, abre tu navegador por defecto a http://localhost. Pero no coincide el Host con rollingdemo.local.
Por ende, el Ingress no matchea y sale el 404.
Es un comportamiento normal. Suele ser confuso, pero no indica error real en el Ingress, sÃ³lo que el Host es distinto.
8. ConclusiÃ³n
El Ingress en sÃ­ estÃ¡ bien configurado (lo demuestran los logs y la respuesta 200 que se ve en el log).
El problema es red/puerto en WSL2: por defecto, 192.168.49.x no es accesible desde tu host sin un tÃºnel que escuche en un puerto privilegiado (80).
Debes asegurarte de que minikube tunnel obtenga los permisos sudo y logre binding a ese puerto. Luego usar un host y una IP que apunte realmente al tÃºnel (muchas veces, 127.0.0.1 rollingdemo.local es mÃ¡s sencillo).
Si ingresas a http://localhost sin Host: rollingdemo.local, es normal ver 404, pues tu Ingress rules.host no coincide con â€œlocalhostâ€.
Con todo esto verificado, deberÃ­as poder (1) encender minikube tunnel, (2) apuntar a http://rollingdemo.local (que resuelve a 127.0.0.1 o a la IP que te funcione) y ver â€œVERSION 1â€ sin problemas. Â¡Ã‰xitos!






TÃº dijiste:
ernesto@ECM:~/kubernetes/k8s-learning/project3-deployment-ingress$ minikube tunnel
âœ…  Tunnel successfully started

ðŸ“Œ  NOTE: Please do not close this terminal as this process must stay alive for the tunnel to be accessible ...

â—  The service/ingress rolling-ing requires privileged ports to be exposed: [80 443]
ðŸ”‘  sudo permission will be asked for it.
ðŸƒ  Starting tunnel for service rolling-ing.

Aqui dice algo de que requiere permisos, pero nunca me los pide en ningun lado

ernesto@ECM:~/kubernetes/k8s-learning$ curl -I http://rollingdemo.local
curl: (28) Failed to connect to rollingdemo.local port 80 after 131869 ms: Connection timed out
ernesto@ECM:~/kubernetes/k8s-learning$ curl -I http://rollingdemo.local
curl: (28) Failed to connect to rollingdemo.local port 80 after 133234 ms: Connection timed out
ernesto@ECM:~/kubernetes/k8s-learning$ cat /etc/hosts | grep rollingdemo.local
192.168.49.2    rollingdemo.local
ernesto@ECM:~/kubernetes/k8s-learning$ getent hosts rollingdemo.local
192.168.49.2    rollingdemo.local
ernesto@ECM:~/kubernetes/k8s-learning$ ping -c 2 rollingdemo.local
PING rollingdemo.local (192.168.49.2) 56(84) bytes of data.

--- rollingdemo.local ping statistics ---
2 packets transmitted, 0 received, 100% packet loss, time 1014ms

ernesto@ECM:~/kubernetes/k8s-learning$ ping -c 2 rollingdemo.local
PING rollingdemo.local (192.168.49.2) 56(84) bytes of data.

--- rollingdemo.local ping statistics ---
2 packets transmitted, 0 received, 100% packet loss, time 1061ms

ernesto@ECM:~/kubernetes/k8s-learning$


ernesto@ECM:~$ sudo lsof -i -P -n | grep LISTEN | grep -E '80|443'
ssh       45890            root    4u  IPv6 11115050      0t0  TCP [::1]:80 (LISTEN)
ssh       45890            root    5u  IPv4 11115051      0t0  TCP 127.0.0.1:80 (LISTEN)
ssh       45890            root    6u  IPv6 11115054      0t0  TCP [::1]:443 (LISTEN)
ssh       45890            root    7u  IPv4 11115055      0t0  TCP 127.0.0.1:443 (LISTEN)
ernesto@ECM:~$



ernesto@ECM:~$ curl -v -H "Host: rollingdemo.local" http://127.0.0.1
*   Trying 127.0.0.1:80...
* Connected to 127.0.0.1 (127.0.0.1) port 80 (#0)
> GET / HTTP/1.1
> Host: rollingdemo.local
> User-Agent: curl/7.81.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< Date: Mon, 06 Jan 2025 22:53:26 GMT
< Content-Type: text/plain; charset=utf-8
< Content-Length: 10
< Connection: keep-alive
< X-App-Name: http-echo
< X-App-Version: 0.2.3
<
VERSION 1
* Connection #0 to host 127.0.0.1 left intact
ernesto@ECM:~$

ernesto@ECM:~$ minikube ip
192.168.49.2
ernesto@ECM:~$
ernesto@ECM:~/kubernetes/k8s-learning$ ping -c 2 192.168.49.2
PING 192.168.49.2 (192.168.49.2) 56(84) bytes of data.

--- 192.168.49.2 ping statistics ---
2 packets transmitted, 0 received, 100% packet loss, time 1031ms

ernesto@ECM:~/kubernetes/k8s-learning$
ernesto@ECM:~$ sudo netstat -tunlp | grep :80
tcp        0      0 127.0.0.1:80            0.0.0.0:*               LISTEN      45890/ssh
tcp6       0      0 ::1:80                  :::*                    LISTEN      45890/ssh
ernesto@ECM:~$
ernesto@ECM:~$ curl -v http://rollingdemo.local
*   Trying 192.168.49.2:80...
* connect to 192.168.49.2 port 80 failed: Connection timed out
* Failed to connect to rollingdemo.local port 80 after 129330 ms: Connection timed out
* Closing connection 0
curl: (28) Failed to connect to rollingdemo.local port 80 after 129330 ms: Connection timed out


ernesto@ECM:~$ sudo ufw status
Status: inactive
ernesto@ECM:~$ 

ernesto@ECM:~$ minikube version
minikube version: v1.34.0
commit: 210b148df93a80eb872ecbeb7e35281b3c582c61
ernesto@ECM:~$
ChatGPT

Pensamiento durante 17 segundos
Viendo tu salida de comandos, estÃ¡ clarÃ­simo que en tu entorno WSL no tienes ruta hacia la IP 192.168.49.2. Por eso:

El ping a 192.168.49.2 da 100% de pÃ©rdida (no hay respuesta).
El curl http://rollingdemo.local (que resuelve a 192.168.49.2) te da timeout.
Sin embargo, el Ingress sÃ­ estÃ¡ vivo y expuesto en localhost:80 vÃ­a minikube tunnel, tal como lo demuestras al hacer:

bash
Copiar cÃ³digo
curl -v -H "Host: rollingdemo.local" http://127.0.0.1
# ...
< HTTP/1.1 200 OK
< ...
VERSION 1
Eso confirma que el Ingress Controller estÃ¡ recibiendo la peticiÃ³n (con ese Host: rollingdemo.local) y te responde â€œVERSION 1â€.

Â¿Por quÃ© no te pide sudo y no ves 192.168.49.2 abierto?
El minikube tunnel en WSL a veces se monta en localhost (127.0.0.1)

En tu netstat se ve:
markdown
Copiar cÃ³digo
ssh    45890  root  4u  IPv6 ...
    LISTEN  127.0.0.1:80
Esto sugiere que el proceso del tÃºnel estÃ¡ â€œocupandoâ€ el puerto 80 en localhost (posiblemente a travÃ©s de una conexiÃ³n SSH interna).
No siempre se ve el prompt de sudo si ya estÃ¡ usando un mecanismo de reenvÃ­o de puertos en WSL.
WSL no tiene ruta a 192.168.49.2

Por defecto, la interfaz 192.168.49.x en minikube (con Docker Desktop) no es alcanzable directamente desde WSL2; solo un â€œvirtual switchâ€ la ve internamente.
El tunnel te abre localhost:80, no la IP 192.168.49.2.
Â¿CÃ³mo acceder con â€œrollingdemo.localâ€ sin usar -H "Host:..." manualmente?
Si deseas que curl http://rollingdemo.local/ (o tu navegador dentro de WSL) funcione automÃ¡ticamente, tienes que apuntar rollingdemo.local a 127.0.0.1 en tu /etc/hosts, en lugar de (o ademÃ¡s de) 192.168.49.2. Por ejemplo:

bash
Copiar cÃ³digo
sudo nano /etc/hosts

# Quita / comenta la lÃ­nea con 192.168.49.2
# 192.168.49.2 rollingdemo.local

# Agrega:
127.0.0.1 rollingdemo.local
Luego:

bash
Copiar cÃ³digo
curl -v http://rollingdemo.local
El DNS resolverÃ¡ rollingdemo.local â†’ 127.0.0.1.
minikube tunnel estÃ¡ escuchando en 127.0.0.1:80.
El request tendrÃ¡ Host: rollingdemo.local.
El Ingress matchea esa regla y devuelve â€œVERSION 1â€.
Con eso ya no necesitas usar -H "Host: rollingdemo.local" cada vez.

Resumen rÃ¡pido
RazÃ³n del fallo: En WSL2 no puedes llegar a 192.168.49.2, aunque sea la â€œIP de minikubeâ€. El minikube tunnel en tu caso se estÃ¡ abriendo solo en localhost:80 y no en â€œla redâ€ con esa IP.
CÃ³mo solucionarlo: Asigna rollingdemo.local a 127.0.0.1 en /etc/hosts. De esa forma, curl http://rollingdemo.local o el navegador funcionarÃ¡, siempre y cuando tengas minikube tunnel corriendo.
Por quÃ© 404 si vas a http://localhost/: El Ingress hace host-based routing. Necesita el Host: rollingdemo.local; â€œlocalhostâ€ no coincide, y NGINX responde con 404.
AsÃ­ ya podrÃ¡s ver tu pÃ¡gina â€œVERSION 1â€ sin problemas. Â¡Ã‰xitos!