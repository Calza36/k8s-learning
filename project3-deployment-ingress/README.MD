He tenido problemas para conseguir esto con mi WSL  + Docker Desktop. 

Aqui los pasos y causas , hasta la solucion

A continuaci√≥n tienes un paso a paso bastante detallado para diagnosticar y resolver por qu√©, a√∫n ejecutando minikube tunnel, tu Ingress no responde en http://rollingdemo.local. El objetivo es que verifiques cada punto y veas exactamente d√≥nde est√° la traba.

Resumen r√°pido: Con WSL2 + Docker Desktop + Minikube, la IP 192.168.49.x normalmente no es alcanzable sin un t√∫nel. Usar minikube tunnel deber√≠a exponer la misma IP que te da minikube ip, y as√≠ (con un /etc/hosts que asocie rollingdemo.local a esa IP) poder hacer curl http://rollingdemo.local. Pero a veces entran en juego otros factores (sudo no concedido, conflicto en el puerto 80, firewall, etc.).

1. Confirmar que ‚Äúrolllingdemo.local‚Äù resuelve a 192.168.49.2 en WSL
En tu consola de WSL, haz:
bash
Copiar c√≥digo
cat /etc/hosts | grep rollingdemo.local
Debe aparecer la l√≠nea:
lua
Copiar c√≥digo
192.168.49.2    rollingdemo.local
Verifica que efectivamente resuelva a esa IP:
bash
Copiar c√≥digo
getent hosts rollingdemo.local
# o
ping -c 2 rollingdemo.local
Si no te da respuesta, algo est√° mal con /etc/hosts.
Si responde a 192.168.49.2, vamos bien al menos en DNS.
2. Revisar si el ‚Äútunnel‚Äù est√° realmente activo y autorizado
Cuando corres:

bash
Copiar c√≥digo
minikube tunnel
ver√°s algo como:

rust
Copiar c√≥digo
‚ùó  The service/ingress rolling-ing requires privileged ports to be exposed: [80 443]
üîë  sudo permission will be asked for it.
üèÉ  Starting tunnel for service rolling-ing.
A veces WSL pedir√° la contrase√±a de sudo (o un sudo prompt) para poder bindear los puertos 80/443 en la interfaz ‚Äúdel host‚Äù. Aseg√∫rate de escribir bien tu contrase√±a y no cerrar esa ventana.

2.1. Confirmar que realmente est√° escuchando
Abre otra terminal de WSL (deja la de minikube tunnel corriendo) y ejecuta:

bash
Copiar c√≥digo
sudo lsof -i -P -n | grep LISTEN | grep -E '80|443'
Si no aparece nada escuchando en :80 o :443 en nombre de minikube o algo similar, entonces es que el t√∫nel no se pudo levantar.
Si s√≠ aparece un proceso de vpnkit / minikube / ‚Äúsomething‚Äù en *:80, significa que est√° escuchando.
A veces, si Docker Desktop tambi√©n ocupa el puerto 80, puede haber conflicto. Revisa que ning√∫n otro servicio (Apache, NGINX local, etc.) est√© ya en el puerto 80.

3. Verificar la conexi√≥n al Ingress dentro de WSL
Sigue con la consola donde ya tienes minikube tunnel activo y haz:

bash
Copiar c√≥digo
curl -v -H "Host: rollingdemo.local" http://127.0.0.1
¬øPor qu√© 127.0.0.1 en lugar de rollingdemo.local?

Porque con minikube tunnel, en muchos casos minikube expone el Ingress/LoadBalancer en localhost:80 (o en la IP que minikube crea internamente).
Importante: El Ingress hace host-based routing usando el encabezado Host: rollingdemo.local.
Si no incluyes -H "Host: rollingdemo.local", es probable que NGINX no encuentre la regla y te devuelva 404 Not Found (el ‚Äúdefault backend‚Äù).
Si ese comando (con -H) te devuelve 200 OK y muestra ‚ÄúVERSION 1‚Äù, significa que el t√∫nel s√≠ est√° funcionando y que la petici√≥n est√° entrando al Ingress.

Si obtienes curl: (7) Connection refused o Timeout, tu t√∫nel no est√° realmente en marcha.
Si obtienes 404 Not Found, el Ingress est√° recibiendo el tr√°fico, pero no coincide con la regla de host. Aseg√∫rate de poner -H "Host: rollingdemo.local".
3.1. Luego probar con curl -v http://rollingdemo.local
Si la l√≠nea en /etc/hosts es 192.168.49.2 rollingdemo.local y el t√∫nel est√° redirigiendo 192.168.49.2:80 ‚Üí contenedor, te√≥ricamente tambi√©n deber√≠a funcionar. Pero a veces en WSL2 la ruta a 192.168.49.2 difiere de la que se configura en localhost.

Si te vuelve a dar ‚ÄúConnection timed out‚Äù, puede indicar que la red de WSL no est√° permitiendo llegar a 192.168.49.2 aunque el t√∫nel est√© abierto.
Una prueba r√°pida:

bash
Copiar c√≥digo
ping -c 2 192.168.49.2
Si ni siquiera ping contesta, es muy probable que no haya NAT hacia esa IP.
En algunos setups de WSL, localhost s√≠ funciona, pero 192.168.49.2 no.
As√≠ que, en entornos WSL, es frecuente que ‚Äúlocalhost‚Äù sea la forma en que el t√∫nel funciona. Esto es lo que produce el famoso nginx 404 al no matchear el host, a menos que agregues la cabecera Host: rollingdemo.local.

4. ‚ÄúPero me abre el navegador en http://localhost/ y veo 404 Not Found, ¬øpor qu√©?‚Äù
Porque tu Ingress tiene la siguiente regla en ingress.yaml:

yaml
Copiar c√≥digo
spec:
  rules:
    - host: rollingdemo.local
      http:
        paths:
        - path: /
          pathType: Prefix
          backend:
            service:
              name: rolling-svc
              port:
                number: 80
El NGINX Ingress s√≥lo atiende la ruta / si el Host HTTP es rollingdemo.local.
Cuando abres http://localhost/ en el navegador, tu navegador manda Host: localhost. El Ingress no tiene ninguna regla para ese host ‚Üí responde con el backend default (404).

Soluciones para ver algo en http://localhost/ directamente:

Opci√≥n r√°pida: En lugar de usar host: rollingdemo.local en tu Ingress, omitir la secci√≥n host: y poner:

yaml
Copiar c√≥digo
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: rolling-svc
            port:
              number: 80
Entonces cualquier host (localhost, 127.0.0.1, etc.) matchea y te servir√° la app.
Pero pierdes la funcionalidad de host-based routing.

O bien: Mantener host: rollingdemo.local, y cuando quieras probar con http://localhost, a√±adir manualmente -H "Host: rollingdemo.local" en el curl, o en tu navegador hacer un override del Host. (En un navegador normal, eso es m√°s complicado sin plugin, por eso preferimos /etc/hosts).

Seguir usando rollingdemo.local en la barra de direcciones del navegador, y en el /etc/hosts (o en Windows C:\Windows\System32\drivers\etc\hosts) poner 127.0.0.1 rollingdemo.local.

Entonces http://rollingdemo.local y Host: rollingdemo.local coinciden, y el Ingress har√° match.
¬°Y ojo!, a veces es mejor apuntar a 127.0.0.1 (en vez de 192.168.49.2) si el t√∫nel est√° realmente escuchando en localhost.
5. Chequeos de firewall y puertos
Si todo lo anterior no funciona y sigues con ‚Äútimeout‚Äù, revisa:

¬øEst√° Docker Desktop u otro servicio usando ya el puerto 80 en WSL?
sudo netstat -tunlp | grep :80
¬øLe diste efectivamente el sudo password al minikube tunnel?
Si el t√∫nel no logra binding a 80, no va a enrutarte nada.
Firewall en WSL: Normalmente, en Ubuntu dentro de WSL no hay ufw activo por defecto, pero revisa con:
sudo ufw status
Si est√° ‚Äúactive‚Äù, prueba sudo ufw allow 80 o desact√≠valo para test.
Versi√≥n de minikube y driver:
Aseg√∫rate de tener algo relativamente actualizado: minikube version
Confirma que tu driver sea docker (que es lo usual con Docker Desktop).
El contenedor NGINX Ingress ya vimos que est√° Running y no hay errores en logs.
6. Resumen del plan de ataque
Ejecutar minikube tunnel en una consola. Concede permisos de sudo cuando lo pida.

Ver si tienes 2 opciones para ‚Äúa d√≥nde‚Äù conectar:

Opci√≥n A:

/etc/hosts ‚Üí 127.0.0.1 rollingdemo.local
Abrir http://rollingdemo.local/ en WSL o en Windows.
Con host: rollingdemo.local, el Ingress har√° match.
Si ves ‚Äú404 Not Found‚Äù, puede ser que tu navegador est√© usando Host: localhost, no ‚Äúrollingdemo.local‚Äù. Aseg√∫rate que la barra de direcciones ponga ‚Äúrollingdemo.local‚Äù.
Opci√≥n B:

/etc/hosts ‚Üí 192.168.49.2 rollingdemo.local
Pero en WSL2 a veces no hay ruta a 192.168.49.2 aunque el t√∫nel est√© activo.
Revisa con ping 192.168.49.2.
A menudo la forma m√°s fiable es apuntar a localhost.
Test con curl -v -H "Host: rollingdemo.local" http://127.0.0.1 (o con la IP a la que tengas en hosts).

Si aqu√≠ obtienes 200 OK y ‚ÄúVERSION 1‚Äù, el Ingress est√° funcionando.
Si a pesar de todo curl se cuelga (‚ÄúConnection timed out‚Äù):

Comprueba que no tengas un firewall local.
Comprueba que tu minikube tunnel no se est√© cerrando por error.
Observa si minikube tunnel muestra alg√∫n log adicional o error.
7. ¬øPor qu√© me abri√≥ un navegador en ‚Äúhttp://localhost/‚Äù con 404?
Porque minikube tunnel a veces, al exponer un Service/Ingress en puerto 80, abre tu navegador por defecto a http://localhost. Pero no coincide el Host con rollingdemo.local.
Por ende, el Ingress no matchea y sale el 404.
Es un comportamiento normal. Suele ser confuso, pero no indica error real en el Ingress, s√≥lo que el Host es distinto.
8. Conclusi√≥n
El Ingress en s√≠ est√° bien configurado (lo demuestran los logs y la respuesta 200 que se ve en el log).
El problema es red/puerto en WSL2: por defecto, 192.168.49.x no es accesible desde tu host sin un t√∫nel que escuche en un puerto privilegiado (80).
Debes asegurarte de que minikube tunnel obtenga los permisos sudo y logre binding a ese puerto. Luego usar un host y una IP que apunte realmente al t√∫nel (muchas veces, 127.0.0.1 rollingdemo.local es m√°s sencillo).
Si ingresas a http://localhost sin Host: rollingdemo.local, es normal ver 404, pues tu Ingress rules.host no coincide con ‚Äúlocalhost‚Äù.
Con todo esto verificado, deber√≠as poder (1) encender minikube tunnel, (2) apuntar a http://rollingdemo.local (que resuelve a 127.0.0.1 o a la IP que te funcione) y ver ‚ÄúVERSION 1‚Äù sin problemas. ¬°√âxitos!






T√∫ dijiste:
ernesto@ECM:~/kubernetes/k8s-learning/project3-deployment-ingress$ minikube tunnel
‚úÖ  Tunnel successfully started

üìå  NOTE: Please do not close this terminal as this process must stay alive for the tunnel to be accessible ...

‚ùó  The service/ingress rolling-ing requires privileged ports to be exposed: [80 443]
üîë  sudo permission will be asked for it.
üèÉ  Starting tunnel for service rolling-ing.

Aqui dice algo de que requiere permisos, pero nunca me los pide en ningun lado

ernesto@ECM:~/kubernetes/k8s-learning$ curl -I http://rollingdemo.local
curl: (28) Failed to connect to rollingdemo.local port 80 after 131869 ms: Connection timed out
ernesto@ECM:~/kubernetes/k8s-learning$ curl -I http://rollingdemo.local
curl: (28) Failed to connect to rollingdemo.local port 80 after 133234 ms: Connection timed out
ernesto@ECM:~/kubernetes/k8s-learning$ cat /etc/hosts | grep rollingdemo.local
192.168.49.2    rollingdemo.local
ernesto@ECM:~/kubernetes/k8s-learning$ getent hosts rollingdemo.local
192.168.49.2    rollingdemo.local
ernesto@ECM:~/kubernetes/k8s-learning$ ping -c 2 rollingdemo.local
PING rollingdemo.local (192.168.49.2) 56(84) bytes of data.

--- rollingdemo.local ping statistics ---
2 packets transmitted, 0 received, 100% packet loss, time 1014ms

ernesto@ECM:~/kubernetes/k8s-learning$ ping -c 2 rollingdemo.local
PING rollingdemo.local (192.168.49.2) 56(84) bytes of data.

--- rollingdemo.local ping statistics ---
2 packets transmitted, 0 received, 100% packet loss, time 1061ms

ernesto@ECM:~/kubernetes/k8s-learning$


ernesto@ECM:~$ sudo lsof -i -P -n | grep LISTEN | grep -E '80|443'
ssh       45890            root    4u  IPv6 11115050      0t0  TCP [::1]:80 (LISTEN)
ssh       45890            root    5u  IPv4 11115051      0t0  TCP 127.0.0.1:80 (LISTEN)
ssh       45890            root    6u  IPv6 11115054      0t0  TCP [::1]:443 (LISTEN)
ssh       45890            root    7u  IPv4 11115055      0t0  TCP 127.0.0.1:443 (LISTEN)
ernesto@ECM:~$



ernesto@ECM:~$ curl -v -H "Host: rollingdemo.local" http://127.0.0.1
*   Trying 127.0.0.1:80...
* Connected to 127.0.0.1 (127.0.0.1) port 80 (#0)
> GET / HTTP/1.1
> Host: rollingdemo.local
> User-Agent: curl/7.81.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< Date: Mon, 06 Jan 2025 22:53:26 GMT
< Content-Type: text/plain; charset=utf-8
< Content-Length: 10
< Connection: keep-alive
< X-App-Name: http-echo
< X-App-Version: 0.2.3
<
VERSION 1
* Connection #0 to host 127.0.0.1 left intact
ernesto@ECM:~$

ernesto@ECM:~$ minikube ip
192.168.49.2
ernesto@ECM:~$
ernesto@ECM:~/kubernetes/k8s-learning$ ping -c 2 192.168.49.2
PING 192.168.49.2 (192.168.49.2) 56(84) bytes of data.

--- 192.168.49.2 ping statistics ---
2 packets transmitted, 0 received, 100% packet loss, time 1031ms

ernesto@ECM:~/kubernetes/k8s-learning$
ernesto@ECM:~$ sudo netstat -tunlp | grep :80
tcp        0      0 127.0.0.1:80            0.0.0.0:*               LISTEN      45890/ssh
tcp6       0      0 ::1:80                  :::*                    LISTEN      45890/ssh
ernesto@ECM:~$
ernesto@ECM:~$ curl -v http://rollingdemo.local
*   Trying 192.168.49.2:80...
* connect to 192.168.49.2 port 80 failed: Connection timed out
* Failed to connect to rollingdemo.local port 80 after 129330 ms: Connection timed out
* Closing connection 0
curl: (28) Failed to connect to rollingdemo.local port 80 after 129330 ms: Connection timed out


ernesto@ECM:~$ sudo ufw status
Status: inactive
ernesto@ECM:~$ 

ernesto@ECM:~$ minikube version
minikube version: v1.34.0
commit: 210b148df93a80eb872ecbeb7e35281b3c582c61
ernesto@ECM:~$
ChatGPT

Pensamiento durante 17 segundos
Viendo tu salida de comandos, est√° clar√≠simo que en tu entorno WSL no tienes ruta hacia la IP 192.168.49.2. Por eso:

El ping a 192.168.49.2 da 100% de p√©rdida (no hay respuesta).
El curl http://rollingdemo.local (que resuelve a 192.168.49.2) te da timeout.
Sin embargo, el Ingress s√≠ est√° vivo y expuesto en localhost:80 v√≠a minikube tunnel, tal como lo demuestras al hacer:

bash
Copiar c√≥digo
curl -v -H "Host: rollingdemo.local" http://127.0.0.1
# ...
< HTTP/1.1 200 OK
< ...
VERSION 1
Eso confirma que el Ingress Controller est√° recibiendo la petici√≥n (con ese Host: rollingdemo.local) y te responde ‚ÄúVERSION 1‚Äù.

¬øPor qu√© no te pide sudo y no ves 192.168.49.2 abierto?
El minikube tunnel en WSL a veces se monta en localhost (127.0.0.1)

En tu netstat se ve:
markdown
Copiar c√≥digo
ssh    45890  root  4u  IPv6 ...
    LISTEN  127.0.0.1:80
Esto sugiere que el proceso del t√∫nel est√° ‚Äúocupando‚Äù el puerto 80 en localhost (posiblemente a trav√©s de una conexi√≥n SSH interna).
No siempre se ve el prompt de sudo si ya est√° usando un mecanismo de reenv√≠o de puertos en WSL.
WSL no tiene ruta a 192.168.49.2

Por defecto, la interfaz 192.168.49.x en minikube (con Docker Desktop) no es alcanzable directamente desde WSL2; solo un ‚Äúvirtual switch‚Äù la ve internamente.
El tunnel te abre localhost:80, no la IP 192.168.49.2.
¬øC√≥mo acceder con ‚Äúrollingdemo.local‚Äù sin usar -H "Host:..." manualmente?
Si deseas que curl http://rollingdemo.local/ (o tu navegador dentro de WSL) funcione autom√°ticamente, tienes que apuntar rollingdemo.local a 127.0.0.1 en tu /etc/hosts, en lugar de (o adem√°s de) 192.168.49.2. Por ejemplo:

bash
Copiar c√≥digo
sudo nano /etc/hosts

# Quita / comenta la l√≠nea con 192.168.49.2
# 192.168.49.2 rollingdemo.local

# Agrega:
127.0.0.1 rollingdemo.local
Luego:

bash
Copiar c√≥digo
curl -v http://rollingdemo.local
El DNS resolver√° rollingdemo.local ‚Üí 127.0.0.1.
minikube tunnel est√° escuchando en 127.0.0.1:80.
El request tendr√° Host: rollingdemo.local.
El Ingress matchea esa regla y devuelve ‚ÄúVERSION 1‚Äù.
Con eso ya no necesitas usar -H "Host: rollingdemo.local" cada vez.

Resumen r√°pido
Raz√≥n del fallo: En WSL2 no puedes llegar a 192.168.49.2, aunque sea la ‚ÄúIP de minikube‚Äù. El minikube tunnel en tu caso se est√° abriendo solo en localhost:80 y no en ‚Äúla red‚Äù con esa IP.
C√≥mo solucionarlo: Asigna rollingdemo.local a 127.0.0.1 en /etc/hosts. De esa forma, curl http://rollingdemo.local o el navegador funcionar√°, siempre y cuando tengas minikube tunnel corriendo.
Por qu√© 404 si vas a http://localhost/: El Ingress hace host-based routing. Necesita el Host: rollingdemo.local; ‚Äúlocalhost‚Äù no coincide, y NGINX responde con 404.
As√≠ ya podr√°s ver tu p√°gina ‚ÄúVERSION 1‚Äù sin problemas. ¬°√âxitos!